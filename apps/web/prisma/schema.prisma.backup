generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())

  teams         TeamMember[]
  scores        Score[]
  audit         AuditLog[]
  registrations Registration[]
}

model Event {
  id            String         @id @default(cuid())
  slug          String         @unique
  name          String
  description   String?
  mode          String
  startsAt      DateTime
  endsAt        DateTime
  tracks        Track[]
  rounds        Round[]
  teams         Team[]
  registrations Registration[]
  submissions   Submission[]
  createdAt     DateTime       @default(now())
}

model Track {
  id      String @id @default(cuid())
  name    String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  eventId String
}

model Round {
  id       String   @id @default(cuid())
  order    Int
  startsAt DateTime
  endsAt   DateTime
  event    Event    @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  eventId  String

  submissions Submission[]
  rubric      Rubric?
  scores      Score[]
}

model Team {
  id            String         @id @default(cuid())
  name          String
  event         Event          @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  eventId       String
  members       TeamMember[]
  submissions   Submission[]
  registrations Registration[]
}

model TeamMember {
  id   String @id @default(cuid())
  role String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  userId String

  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  teamId String

  @@unique([userId, teamId])
}

model Registration {
  id     String @id @default(cuid())
  status String

  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  eventId String

  user   User?   @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  userId String?

  team   Team?   @relation(fields: [teamId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  teamId String?
}

/**
 * Submission model with proper referential integrity for PostgreSQL
 */
model Submission {
  id       String  @id @default(cuid())
  title    String
  repoUrl  String?
  videoUrl String?
  status   String

  // Direct event relationship
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId String

  // Team relationship
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId String

  // Optional round relationship
  round   Round?  @relation(fields: [roundId], references: [id], onDelete: SetNull)
  roundId String?

  scores    Score[]
  createdAt DateTime @default(now())
}

model Rubric {
  id       String      @id @default(cuid())
  name     String
  criteria Criterion[]

  round   Round?  @relation(fields: [roundId], references: [id], onDelete: Cascade)
  roundId String? @unique
}

model Criterion {
  id       String @id @default(cuid())
  label    String
  weight   Float  @default(1.0)
  scaleMax Int    @default(10)

  rubric   Rubric @relation(fields: [rubricId], references: [id], onDelete: Cascade)
  rubricId String
}

model Score {
  id      String  @id @default(cuid())
  value   Int
  comment String?

  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId String

  judge   User   @relation(fields: [judgeId], references: [id], onDelete: Cascade)
  judgeId String

  round   Round?  @relation(fields: [roundId], references: [id], onDelete: SetNull)
  roundId String?

/**
 * For Score:
 * - Keep submission CASCADE (delete a submission → delete its scores).
 * - Make round NO ACTION so there’s no Round→Score referential action.
 */
model Score {
  id      String  @id @default(cuid())
  value   Int
  comment String?

  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  submissionId String

  judge   User   @relation(fields: [judgeId], references: [id], onDelete: Cascade)
  judgeId String

  round   Round?  @relation(fields: [roundId], references: [id], onDelete: SetNull)
  roundId String?

  createdAt DateTime @default(now())
}

model AuditLog {
  id        String   @id @default(cuid())
  actor     User?    @relation(fields: [actorId], references: [id], onDelete: SetNull)
  actorId   String?
  action    String
  target    String?
  meta      String? // JSON stored as text - can use Json type in PostgreSQL if needed
  createdAt DateTime @default(now())
}
